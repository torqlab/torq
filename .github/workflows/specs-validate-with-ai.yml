name: Validate Specs with AI

on:
  push:
    branches: [main]
    paths:
      - "openspec/**"
      - "packages/specs-guardrails/validate-specs-with-ai"
      - ".github/workflows/specs-validate-with-ai.yml"
  workflow_dispatch:
    inputs:
      specs:
        description: 'Spec file paths to validate (comma-separated) or "*" for all specs'
        required: false
        type: string
        default: ''

jobs:
  specs-validate-with-ai:
    name: Validate Specs with AI
    environment:
      name: specs-validate-with-ai-approval
    runs-on: self-hosted

    outputs:
      validation-status: ${{ steps.validation.outputs.result }}
      validation-summary-json: ${{ steps.expose-validation-summary-json.outputs.validation_summary_json }}

    permissions:
      contents: read

    env:
      DIAL_KEY: ${{ secrets.DIAL_KEY }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0  # Fetch full history to ensure we can compare with any previous commit

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 24

      - name: Setup bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Ensure jq is available
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y jq
          fi

      - name: Install dev dependencies
        run: bun install --only dev

      - name: Log basic validation prompts (w/o injected specs)
        run: |
          echo "=== System prompt ==="
          cat prompts/validate-specs.system.md
          echo ""
          echo "=== User prompt ==="
          cat prompts/validate-specs.user.md

      - name: Detect changed spec files
        id: changed-specs
        run: |
          # Handle manual workflow_dispatch input
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ inputs.specs }}" ]; then
            if [ "${{ inputs.specs }}" = "*" ]; then
              # "*" means validate all specs
              echo "has_changed_specs=false" >> "$GITHUB_OUTPUT"
              echo "Manual run: validating all specs (specs=*)"
            else
              # Convert comma-separated paths to absolute paths
              SPEC_PATHS=$(echo "${{ inputs.specs }}" | tr ',' '\n' | while read -r file; do
                # Trim whitespace
                file=$(echo "$file" | xargs)
                if [ -n "$file" ]; then
                  # Convert to absolute path if relative
                  if [[ "$file" != /* ]]; then
                    echo "$(pwd)/$file"
                  else
                    echo "$file"
                  fi
                fi
              done | tr '\n' ',' | sed 's/,$//')
              echo "spec_paths=$SPEC_PATHS" >> "$GITHUB_OUTPUT"
              echo "has_changed_specs=true" >> "$GITHUB_OUTPUT"
              echo "Manual run: validating specified spec files:"
              echo "${{ inputs.specs }}"
            fi
          else
            # Original behavior: detect changed files for push events
            # Get the base commit for comparison
            # For push events, use github.event.before if available, otherwise HEAD~1
            if [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              BASE_SHA="${{ github.event.before }}"
            else
              # Fallback: try HEAD~1, or use HEAD if it's the first commit
              BASE_SHA=$(git rev-parse HEAD~1 2>/dev/null || echo "HEAD")
            fi
            
            # Get changed files and filter for .spec.md files *within openspec*
            CHANGED_SPECS=$(git diff --name-only --diff-filter=ACMRT "$BASE_SHA" HEAD 2>/dev/null | grep '^openspec/.*spec\.md$' || true)
            
            if [ -n "$CHANGED_SPECS" ]; then
              # Convert newlines to commas and make paths absolute
              SPEC_PATHS=$(echo "$CHANGED_SPECS" | while read -r file; do
                echo "$(pwd)/$file"
              done | tr '\n' ',' | sed 's/,$//')
              echo "spec_paths=$SPEC_PATHS" >> "$GITHUB_OUTPUT"
              echo "has_changed_specs=true" >> "$GITHUB_OUTPUT"
              echo "Found changed spec files:"
              echo "$CHANGED_SPECS"
            else
              echo "has_changed_specs=false" >> "$GITHUB_OUTPUT"
              echo "No changed spec files found"
            fi
          fi

      - name: Run specs validation
        run: |
          mkdir -p .specs-validation/ai
          
          if [ "${{ steps.changed-specs.outputs.has_changed_specs }}" = "true" ]; then
            echo "Validating only changed spec files..."
            bun run --filter @pace/specs-guardrails validate-specs:ai -- --specFilePaths "${{ steps.changed-specs.outputs.spec_paths }}" --systemPrompt $(pwd)/prompts/validate-specs.system.md --userPrompt $(pwd)/prompts/validate-specs.user.md > .specs-validation/ai/raw-output.txt 2>&1 || {
              echo "Validation script failed. Raw output:"
              cat .specs-validation/ai/raw-output.txt
              # Create a valid error JSON response
              echo '{"result": "INVALID", "violations": [], "notes": ["Validation script execution failed"]}' > .specs-validation/ai/result.json
            }
          else
            echo "No changed spec files detected, validating all specs..."
            bun run --filter @pace/specs-guardrails validate-specs:ai -- --rootDir $(pwd)/openspec/specs --systemPrompt $(pwd)/prompts/validate-specs.system.md --userPrompt $(pwd)/prompts/validate-specs.user.md > .specs-validation/ai/raw-output.txt 2>&1 || {
              echo "Validation script failed. Raw output:"
              cat .specs-validation/ai/raw-output.txt
              # Create a valid error JSON response
              echo '{"result": "INVALID", "violations": [], "notes": ["Validation script execution failed"]}' > .specs-validation/ai/result.json
            }
          fi
          
          # Sanitize the raw output: strip Bun prefix and remove "Exited with code" line
          # Only do this if result.json doesn't exist (command succeeded)
          if [ ! -f .specs-validation/ai/result.json ] && [ -f .specs-validation/ai/raw-output.txt ]; then
            # Show raw output for debugging
            echo "Raw validator output:"
            cat .specs-validation/ai/raw-output.txt
            echo ""
            
            # Strip the Bun prefix and filter out non-JSON lines
            sed 's/^@pace\/specs-guardrails validate-specs:ai: //' .specs-validation/ai/raw-output.txt | \
              grep -v '^Exited with code' | \
              grep -v '^$' > .specs-validation/ai/result.json || {
              echo "Failed to sanitize output. Creating error response."
              echo '{"result": "INVALID", "violations": [], "notes": ["Failed to parse validation output"]}' > .specs-validation/ai/result.json
            }
          fi
          
          # Validate that the output is valid JSON
          if ! jq empty .specs-validation/ai/result.json 2>/dev/null; then
            echo "Error: result.json is not valid JSON after sanitization. Content:"
            cat .specs-validation/ai/result.json
            echo '{"result": "INVALID", "violations": [], "notes": ["Invalid JSON output from validation script"]}' > .specs-validation/ai/result.json
          fi

      - name: Expose validation result JSON (as base64)
        id: expose-validation-summary-json
        run: |
          SUMMARY_B64=$(base64 < .specs-validation/ai/result.json | tr -d '\n')
          echo "validation_summary_json=$SUMMARY_B64" >> "$GITHUB_OUTPUT"

      - name: Parse validation result
        id: validation
        run: |
          RESULT=$(jq -r '.result // "INVALID"' .specs-validation/ai/result.json)
          VIOLATION_COUNT=$(jq '[.violations[]?] | length' .specs-validation/ai/result.json)
          NOTES_COUNT=$(jq '[.notes[]?] | length' .specs-validation/ai/result.json)

          echo "result=$RESULT" >> "$GITHUB_OUTPUT"
          echo "violation_count=$VIOLATION_COUNT" >> "$GITHUB_OUTPUT"
          echo "notes_count=$NOTES_COUNT" >> "$GITHUB_OUTPUT"

      - name: Extract validated spec paths
        id: extract-validated-specs
        run: |
          mkdir -p .specs-validation/ai
          
          if [ "${{ steps.changed-specs.outputs.has_changed_specs }}" = "true" ]; then
            # Extract spec paths from comma-separated list (already absolute paths)
            echo "${{ steps.changed-specs.outputs.spec_paths }}" | tr ',' '\n' | jq -R . | jq -s . > .specs-validation/ai/validated-specs.json
          else
            # Find all spec.md files from openspec/specs directory only
            echo "Extracting validated spec paths from ./openspec/specs..."
            ROOT_DIR=$(pwd)
            
            # Find files and show what we find for debugging
            SPEC_FILES=$(find ./openspec/specs -name "*spec.md" -type f 2>/dev/null || true)
            
            if [ -z "$SPEC_FILES" ]; then
              echo "Warning: No spec files found in ./openspec/specs"
              echo "[]" > .specs-validation/ai/validated-specs.json
            else
              echo "Found spec files:"
              echo "$SPEC_FILES"
              
              # Convert to absolute paths and create JSON array
              echo "$SPEC_FILES" | while read -r file; do
                # Convert relative path to absolute path
                if [[ "$file" == ./* ]]; then
                  echo "$ROOT_DIR${file#.}"
                elif [[ "$file" == /* ]]; then
                  echo "$file"
                else
                  echo "$ROOT_DIR/$file"
                fi
              done | sort | jq -R . | jq -s . > .specs-validation/ai/validated-specs.json
            fi
            
            echo "Validated specs JSON:"
            cat .specs-validation/ai/validated-specs.json
          fi

      - name: Check for execution errors
        if: steps.validation.outputs.notes_count != '0'
        run: |
          echo "‚ö†Ô∏è Validation script encountered errors:"
          jq -r '.notes[]?' .specs-validation/ai/result.json | while read -r note; do
            echo "  - $note"
          done
          echo ""
          echo "This indicates the validation script failed to execute properly."
          echo "Please check the logs above for details."

      - name: Render validation summary
        if: always()
        run: |
          {
            echo "# üìã Specs Validation Result"
            echo ""
            echo "| Metric | Value |"
            echo "|-------|-------|"
            echo "| Result | **${{ steps.validation.outputs.result }}** |"
            echo "| Violations | ${{ steps.validation.outputs.violation_count }} |"
            if [ "${{ steps.validation.outputs.notes_count }}" != "0" ]; then
              echo "| Notes | ${{ steps.validation.outputs.notes_count }} |"
            fi
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"
          
          # Render notes if they exist
          if [ "${{ steps.validation.outputs.notes_count }}" != "0" ]; then
            {
              echo "## ‚ö†Ô∏è Validation Notes" >> "$GITHUB_STEP_SUMMARY"
              echo "" >> "$GITHUB_STEP_SUMMARY"
              jq -r '.notes[]?' .specs-validation/ai/result.json | while read -r note; do
                echo "- $note" >> "$GITHUB_STEP_SUMMARY"
              done
              echo "" >> "$GITHUB_STEP_SUMMARY"
            }
          fi

      - name: Render validation results
        if: always()
        run: |
          echo "## üìã All Validated Specs" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "| Spec ID | Status | Rule | Description |" >> "$GITHUB_STEP_SUMMARY"
          echo "|------|------|------|-------------|" >> "$GITHUB_STEP_SUMMARY"

          # Use jq to process all specs and violations together
          jq -r --slurpfile validated_specs .specs-validation/ai/validated-specs.json '
            # Helper function to extract display spec ID (same logic as violations)
            def extract_display_id($path):
              if $path == null or $path == "" or $path == "global" then "global"
              elif ($path | test(".*/openspec/specs/([^/]+)/spec\\.md")) then
                ($path | capture(".*/openspec/specs/(?<spec_id>[^/]+)/spec\\.md") | .spec_id)
              elif ($path | test("/spec\\.md$")) then
                ($path | split("/") | .[length - 2])
              else $path end;

            # Normalize path for matching (remove leading/trailing whitespace, handle absolute/relative)
            def normalize_path($path):
              ($path | tostring | gsub("^\\s+|\\s+$"; "")) as $trimmed |
              if $trimmed == "" or $trimmed == "global" then "global"
              else $trimmed end;

            # Build violations map: spec_id -> violations array
            [.violations[]? | select(.spec_id != null and .spec_id != "" and .spec_id != "global")] as $all_violations |
            ($all_violations | group_by(.spec_id) | map({key: .[0].spec_id, value: .}) | from_entries) as $violations_by_spec |

            # Process each validated spec
            $validated_specs[0][] as $spec_path |
            normalize_path($spec_path) as $normalized_spec_path |
            extract_display_id($spec_path) as $display_id |
            
            # Try to find violations for this spec (check both exact match and normalized match)
            (if $violations_by_spec[$spec_path] then $violations_by_spec[$spec_path]
             elif $violations_by_spec[$normalized_spec_path] then $violations_by_spec[$normalized_spec_path]
             else [] end) as $spec_violations |
            
            if ($spec_violations | length) > 0 then
              # Spec has violations - show each violation
              $spec_violations[] |
              "| \($display_id) | ‚ùå Invalid | \(.rule // "unknown") | \(.description // "No description") |"
            else
              # Spec is valid
              "| \($display_id) | ‚úÖ Valid | - | No issues found |"
            end
          ' .specs-validation/ai/result.json >> "$GITHUB_STEP_SUMMARY"

          # Handle global violations (violations without spec_id)
          global_violations=$(jq -r '[.violations[]? | select(.spec_id == null or .spec_id == "" or .spec_id == "global")] | if length > 0 then . else empty end' .specs-validation/ai/result.json)
          if [ -n "$global_violations" ] && [ "$global_violations" != "[]" ]; then
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "### Global Issues" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "| Spec ID | Status | Rule | Description |" >> "$GITHUB_STEP_SUMMARY"
            echo "|------|------|------|-------------|" >> "$GITHUB_STEP_SUMMARY"
            echo "$global_violations" | jq -r '.[] | 
              "| global | ‚ùå Invalid | \(.rule // "unknown") | \(.description // "No description") |"
            ' >> "$GITHUB_STEP_SUMMARY"
          fi

  specs-fix-with-ai-approval:
    name: Fix Specs with AI Approval
    needs: specs-validate-with-ai
    if: always() && needs.specs-validate-with-ai.outputs.validation-status == 'INVALID'
    runs-on: ubuntu-latest
    environment:
      name: specs-fix-with-ai-approval
    steps:
      - name: Approval granted
        run: echo "Approval granted for fixing AI validation issues with AI"

  specs-fix-with-ai:
    name: Fix Specs with AI
    needs: [specs-validate-with-ai, specs-fix-with-ai-approval]
    if: always() && needs.specs-validate-with-ai.outputs.validation-status == 'INVALID' && needs.specs-fix-with-ai-approval.result == 'success'
    uses: ./.github/workflows/specs-fix-with-ai.yml
    secrets: inherit
    permissions:
      contents: write
      pull-requests: write
    with:
      summary: ${{ needs.specs-validate-with-ai.outputs.validation-summary-json }}

  finally:
    name: Finalize AI-Driven Specs Validation
    needs: [specs-validate-with-ai, specs-fix-with-ai]
    runs-on: self-hosted

    steps:
      - name: Fail pipeline on failed validation
        if: needs.specs-validate-with-ai.outputs.validation-status == 'INVALID'
        run: |
          echo "‚ùå Specs validation failed! Please review the validation summary above and address the issues."
          echo "ü§ñ Or rely on the agent which already tries to fix the issues."
          exit 1
